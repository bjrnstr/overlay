<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3:00 Timer - Sekundensynchroner Rahmen</title>

<!-- Google Font -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Jersey+25&display=swap" rel="stylesheet">

<style>
  :root{
    --text-color: #08CFD3;
    --stroke-color: #0098fe;
  }

  html,body{
    height:100%;
    margin:0;
    background: transparent; /* wichtig für OBS */
  }

  .wrap {
    width: 720px;           /* Breite des Elements - anpassen möglich */
    height: 240px;          /* Höhe des Elements */
    display:flex;
    justify-content:center;
    align-items:center;
    position: relative;
    margin: 0 auto;
  }

  /* Timer-Text */
  #timer {
    font-family: "Jersey 25", Arial, sans-serif;
    font-size: 150px;           /* gewünschte Größe */
    color: var(--text-color);
    text-align: center;
    z-index: 3;
    pointer-events: none;
    line-height: 1;
  }

  /* SVG-Frame */
  .frame {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
  }

  svg { width:100%; height:100%; display:block; }

  .outline {
    stroke: var(--stroke-color);
    stroke-width: 8;
    stroke-linecap: round;
    fill: none;
    filter: drop-shadow(0 0 8px var(--stroke-color));
  }

</style>
</head>
<body>
  <div class="wrap" aria-hidden="true">
    <!-- SVG Rechteckpfad: Pfadlänge wird normiert mit pathLength="1" -->
    <div class="frame">
      <svg viewBox="0 0 720 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Der Pfad beschreibt das Rechteck mit abgerundeten Ecken -->
        <path id="rectPath" class="outline" pathLength="1"
          d="M20 20 H700 A20 20 0 0 1 720 40 V200 A20 20 0 0 1 700 220 H20 A20 20 0 0 1 0 200 V40 A20 20 0 0 1 20 20 Z"/>
      </svg>
    </div>

    <div id="timer">03:00</div>
  </div>

<script>
/* ====== Einstellungen ====== */
const TOTAL_SECONDS = 180; // 3 Minuten

/* Elemente */
const timerEl = document.getElementById('timer');
const pathEl  = document.getElementById('rectPath');

/* Setup: Stroke-Dash so setzen, dass pathLength=1 als Referenz genutzt wird */
pathEl.style.strokeDasharray = '1';      // gesamter Pfad
pathEl.style.strokeDashoffset = '1';     // komplett "leer"

/* Zeitvariablen */
let timeLeft = TOTAL_SECONDS;
let running = true;

/* Timing für präzise Sekundensynchronisation */
let lastTick = performance.now();
let animStart = performance.now(); // Startzeitpunkt der laufenden Sekunde

/* Hilfsfunktion: Render Timer-Text */
function renderTimer(sec){
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  timerEl.textContent = String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}

/* Startzustand */
renderTimer(timeLeft);

/* Hauptloop: requestAnimationFrame für flüssige 1s-Umlauf-Animation */
function loop(now){
  if (!running) return;

  // ganze Sekunden verarbeiten (falls Frameverlust)
  if (now - lastTick >= 1000){
    const ticks = Math.floor((now - lastTick) / 1000);
    timeLeft = Math.max(0, timeLeft - ticks);
    lastTick += ticks * 1000;
    // restart der 1s-Animation
    animStart = now;
    // wenn 0 erreicht, stoppen wir die Animation (rahmen voll)
    if (timeLeft === 0){
      renderTimer(0);
      pathEl.style.strokeDashoffset = '0'; // komplett gezeichnet
      running = false;
      return;
    }
  }

  // t: Sekundenbruchteil seit animStart (0..1)
  const t = (now - animStart) / 1000;
  const frac = Math.max(0, Math.min(1, t));

  // strokeDashoffset von 1 -> 0 innerhalb einer Sekunde:
  // Wir setzen offset = 1 - frac  (1 -> 0 schnell)
  const offset = 1 - frac;
  pathEl.style.strokeDashoffset = offset;

  // Timer-Text zeigt verbleibende Sekunden (ganzzahlig)
  renderTimer(timeLeft);

  requestAnimationFrame(loop);
}

/* Initialisierung starten */
(function init(){
  lastTick = performance.now();
  animStart = performance.now();
  running = true;
  requestAnimationFrame(loop);
})();

/* Optional: Exposed Reset-Funktion (für Browser-Konsole) */
window.resetTimer = function(){
  timeLeft = TOTAL_SECONDS;
  lastTick = performance.now();
  animStart = performance.now();
  pathEl.style.strokeDashoffset = '1';
  if (!running){ running = true; requestAnimationFrame(loop); }
};

</script>
</body>
</html>
